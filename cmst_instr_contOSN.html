<!DOCTYPE html>
<html>
  <!--
  Task: Perceptual-baseline control task in cMST
  Author: Gavin Stark
  Forked from main cMST-Online on 11/20/19 and modified for mobile / Cordova
  Forked again on 8/20/20, pulled out Cordova, and setup for JATOS

Revised: November 20, 2019 (CELS) for Cordova
   11/22/19 (CELS) - cleanup parameter section
   11/25 (CELS): Button size increase
   12/4/19 (CELS): Using .replace not .href and will take you back to index.html if the end
   12/5/19 (CELS): Styles to alter text/button sizes, ensuring deviceready, meta-tag
   12/6/19 (CELS): Shifted data saving to savedata.js and setup to allow local backup save on iOS
   4/13/20 (CELS): Goes to end.html if this is the last phase
   4/16/20 (CELS): Will detect if on SONA and go back there for credit
   8/20/20 (CELS): Forked off and reworked for JATOS
   8/24/20 (CELS): Fixed jumping stimuli when using button response mode
   5/31/22 (CELS): Added bit about blank screen in main task
   10/21/22 (CELS): Updated default to buttons 
   2/28/23 (CELS): Updated to jsPsych7
   8/16/23 (CELS): Fixed for versions without setup.html to progress to next phase
   8/30/23 (CELS): Added getID() to come up with a good sid 
   10/23/23 (CELS): Multi-lang support using Honeycomb style language file
  
 Optional parameters:
  [sid=##]: Subject ID -- used for data file name (default=1234)
  [resp=X]: Response mode -- set to 'keyboard' to use keys, anything else to use buttons (default=button)
  [rand=#]: Should which stimuli are shown as repeats vs. lures be randomized? (default=0)
  [q_pcon=pagename]: Base of HTML filename to add into the queue after this task (default=null)

 -->

<head>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' data: gap: 'unsafe-inline' 'unsafe-eval' 
    https://fonts.gstatic.com http://www.stark-labs.com/exp/jsPsych/mobile_cMST/append_log.php http://www.stark-labs.com/exp/jsPsych/mobile_cMST/write_data_file.php; 
    script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net;
    connect-src 'self' https://cdn.jsdelivr.net http://www.stark-labs.com;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/css; 
    media-src *; 
    img-src 'self' data: content:;">

  <script type="text/javascript" src="jatos.js"></script>
  <script type="text/javascript" src="js/index.js"></script>
  <script src="js/jquery-3.1.1.min.js"></script>
  <script src="js/jspsych_731/dist/jspsych.js"></script>
  <script src="js/jspsych_731/dist/plugin-html-keyboard-response.js"></script>
  <script src="js/jspsych_731/dist/plugin-html-button-response.js"></script>
  <script src="js/jspsych_731/dist/plugin-canvas-keyboard-response.js"></script>
  <script src="js/jspsych_731/dist/plugin-canvas-button-response.js"></script>
  <script src="js/jspsych_731/dist/plugin-categorize-image.js"></script>
  <script src="js/plugin-categorize-image-buttons.js"></script>
  <script src="js/jspsych_731/dist/plugin-preload.js"></script>
  <script src="js/jspsych_731/dist/plugin-fullscreen.js"></script>
  <script src="helpers.js"></script>
  <link rel="stylesheet" href="css/jspsych.css"></link>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    rel="preload"
    href="css/fonts/ComicRelief-Regular.woff2"
    as="font"
    type="font/woff2"
    crossorigin
  />
  <link
    rel="preload"
    href="css/fonts/ComicRelief-Bold.woff2"
    as="font"
    type="font/woff2"
    crossorigin
  />
  <style>
    
  .image-btn-text text {
    font-size: 1.6em;
  }

  .mobile .image-btn-text text{
    stroke-width: 12;
    font-size: 1.5em;
  }

  .image-btn-text.kr text,
  .image-btn-text.ru text{
    font-size: 0.9em;
    stroke-width: 8;
  }

  .image-btn-text.nl  text{
    font-size: 0.9em;
    stroke-width: 10;
  }
  
  .mobile .image-btn-text.kr text,
  .mobile .image-btn-text.nl text{
    font-size: 0.8em;
    stroke-width: 8;
  }

  .mobile .image-btn-text.ru text{
    font-size: 1.2em;
    stroke-width: 12;
  }
    
  .tablet .image-btn-text text {
    font-size: 1.5em;
  }
  
  .tablet .image-btn-text.kr text {
    font-size: 1em;
    stroke-width: 8;
  }
 
  .tablet .image-btn-text.nl text {
    font-size: .9em;
    stroke-width: 8;
  }

  .tablet .image-btn-text.ru text{
    font-size: 1.2em;
    stroke-width: 10;
  }

  .jspsych-content {
    height: 100svh;
    width: 100svw;
    justify-content: space-around;
    opacity: 0;
  }

  .jspsych-content.ready {
    opacity: 1;
  }

  .jspsych-categorize-image-buttons-stimulus {
    flex-shrink: 0;
    margin: 10px auto;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .prompt-container {
    flex-grow: 1;
    width: 100%;
    min-height: 30px;
  }

  .prompt_text {
    margin: 0;
    padding: 0;
    text-align: center;
    line-height: 1.3;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .jspsych-content {
    visibility: hidden !important;
  }

  .jspsych-content.ready {
    visibility: visible !important;
  }
  </style>
</head>
<script>


function waitFor(conditionFunction) {
  const poll = resolve => {
  if(conditionFunction()) resolve();
    else setTimeout(_ => poll(resolve), 400);
  }
  return new Promise(poll)
}

function getID() {
  // Try to get a reasonable ID code for this person.  You can use the URL with a "sid" parameter or
  // specify one in the jatos studySessionData. If not, it'll use the JATOS workerId.
  // URL > studySession > workerID
  var sid=jatos.urlQueryParameters.sid;
  if (sid == undefined) {
    sid=jatos.studySessionData['sid'];
  }
  if (typeof sid == 'undefined') {
    if (typeof jatos.workerId !== 'undefined') { // At least try the workerID
      sid = jatos.workerId;
    }
    else { sid=1234; }
  }
  return sid
}

jatos.onLoad(async function() {
  const phasename='cmst_instr_contOSN';
  var sid=getID();
  var resp_mode='button';
  if (jatos.studySessionData['resp_mode'] == 'keyboard') {
    resp_mode='key';
  }
  else if (jatos.studySessionData['resp_mode'] == 'key') {
    resp_mode='key';
  }

  var lang='en';
  if (typeof jatos.studySessionData['lang'] !== 'undefined') {
    lang=jatos.studySessionData['lang'];
  }
  if (jatos.studyJsonInput && typeof jatos.studyJsonInput['lang'] !== 'undefined' ) { 
    lang=jatos.studyJsonInput['lang']
  }
  if (jatos.batchJsonInput && typeof jatos.batchJsonInput['lang'] !== 'undefined' ) { 
    lang=jatos.batchJsonInput['lang']
  }

  var classicGraphics = 0;
  if (typeof jatos.studySessionData['classic_graphics'] !== 'undefined') {
    classicGraphics = jatos.studySessionData['classic_graphics'];
  }
  if (jatos.studyJsonInput && typeof jatos.studyJsonInput['classic_graphics'] !== 'undefined' ) { 
    classicGraphics=jatos.studyJsonInput['classic_graphics']
  }
  if (jatos.batchJsonInput && typeof jatos.batchJsonInput['classic_graphics'] !== 'undefined' ) { 
    classicGraphics=jatos.batchJsonInput['classic_graphics']
  }

  // load honeycomb version of lang file
  console.log('loading json lang: ',lang)
  var langfile='lang/omst_'+lang+'.json';
  var json_prompts=null;
  $.getJSON(langfile,function( data ) {
    json_prompts=data;
    console.debug(langfile + ' loaded...ish');
  });
  await waitFor(_ => json_prompts !== null);
  console.log(json_prompts['task']['name'])
  let prompts=json_prompts['instructions']; // Load in this phase's section

  const preload_fnames = new Array(17);

  preload_fnames.push(
    "img/assets/blank_blue.png",
    "img/assets/blank_blue_pressed.png",
    "img/assets/blank_green.png",
    "img/assets/blank_green_pressed.png",
    "img/assets/blank_red.png",
    "img/assets/blank_red_pressed.png",
    'img/assets/foil_1032_border.png',
    'img/assets/foil_1033_border.png',
    'img/assets/pcon026a_border.png',
    'img/assets/pcon026b_border.png',
    'img/pcon026a.jpg',
    'img/pcon026b.jpg',
    'img/assets/foil_1035_border.png',
    'img/assets/pcon028a_border.png',
    'img/assets/pcon028b_border.png',
    'img/pcon028a.jpg',
    'img/pcon028b.jpg',
  );

  var jsPsych = initJsPsych({on_finish: function() {
      if (0) { jsPsych.data.displayData(); }
      else {
        var order=jatos.studySessionData["order"];
        jatos.studySessionData["taskindex"] += 1;
        if (typeof order === 'undefined') {
          // We don't have an 'order' setup, so assume it's 1-N
          console.log('faking an order')
          order=Array(jatos.componentList.length).fill().map((e,i)=>i+1);
          jatos.studySessionData["taskindex"]=jatos.componentPos;
          //console.log(order);
          //console.log(jatos.studySessionData["taskindex"]);
        }
        var expdata = jsPsych.data.get().json();
        // Submit results to JATOS and queue the end or next task
        if (typeof order === 'undefined' || order.length == jatos.studySessionData["taskindex"]) { 
          // we're done
          // Check if this came from SONA - should have URL.sid and .sona
          if (typeof jatos.urlQueryParameters.sid === 'undefined' || typeof jatos.urlQueryParameters.sona === 'undefined' ||
              typeof jatos.studyJsonInput['experiment_id'] === 'undefined' || typeof jatos.studyJsonInput['credit_token'] === 'undefined') {
            jatos.submitResultData(expdata,jatos.endStudy);
          }
          else {
            var redirect='https://uci.sona-systems.com/webstudy_credit.aspx?experiment_id='+jatos.studyJsonInput['experiment_id']+
              '&credit_token='+jatos.studyJsonInput['credit_token']+'&survey_code='+jatos.urlQueryParameters.sid;
            jatos.endStudyAndRedirect(redirect,expdata);
          }
        }
        else {
          // submit and start the next
          jatos.submitResultData(expdata, () => { jatos.startComponentByPos(order[jatos.studySessionData["taskindex"]]) });
        }
      }
    }
  });
  const device = getDeviceType();
  console.log("have device " + device);
  const isMobile = device[0];
  const isTablet = device[1];
  const smallScreen = device[2];
  console.log("smallScreen " + smallScreen);
  const canvasWidth = isMobile ? window.innerWidth * 0.9 : window.innerWidth * .9;
  const canvasHeight = isMobile ? window.innerHeight * 0.7 : smallScreen ? window.innerHeight * 0.75 : isTablet ? window.innerHeight * 0.8 : window.innerHeight * .75;
  const fontScale = isMobile ? 1.5 : 1.0;
  const stimScale = isMobile ? 2 : smallScreen ? 0.85: isTablet ? 1.2 : 1.0;
  document.body.classList.add(isMobile ? 'mobile' : 'desktop');
  if (smallScreen) {document.body.classList.add('smallScreen');}
  if (isTablet) {document.body.classList.add('tablet');}
  if (classicGraphics) {document.body.classList.add('classic');}
  jsPsych.data.addProperties({
    task: phasename,
    subject: sid,
  });

  function fitTrialToScreen() {
    const container = document.querySelector('.jspsych-content');
    if (!container) return;
    
    const totalHeight = window.offsetHeight ? 
      window.offsetHeight : window.innerHeight;
    const totalWidth = window.visualViewport ? 
      window.visualViewport.width : window.innerWidth;

    
    // Get the three main sections
    const promptContainer = document.querySelector('.prompt-container');
    const stimulusContainer = document.querySelector('.jspsych-categorize-image-buttons-stimulus');
    const buttonContainer = document.querySelector('#jspsych-categorize-image-buttons-response-btngroup');
    
    if (!promptContainer || !stimulusContainer || !buttonContainer) return;
    
    console.log('Total height:', totalHeight);
    console.log('Device type - isMobile:', isMobile, 'isTablet:', isTablet, 'smallScreen:', smallScreen, 'desktop:', !smallScreen && !isMobile && !isTablet);
    
    // MOBILE: Buttons stacked (2 top, 1 bottom), vertical layout
    if (isMobile) {
      const buttonHeight = buttonContainer.offsetHeight;
      console.log('Button height:', buttonHeight);
      
      // Stimulus should be square at 90vw
      const stimulusSize = totalWidth * 0.90;
      console.log('Stimulus size:', stimulusSize);
      
      // Remaining space for prompt
      const margin = 40;
      const promptHeight = totalHeight - stimulusSize - buttonHeight - margin;
      console.log('Prompt height:', promptHeight);
      
      // Ensure prompt has minimum viable space
      if (promptHeight < 30) {
        console.warn('Prompt space too small, adjusting layout');
        const adjustedStimSize = totalHeight - buttonHeight - 60 - margin;
        stimulusContainer.style.width = adjustedStimSize + 'px';
        stimulusContainer.style.height = adjustedStimSize + 'px';
        promptContainer.style.height = '60px';
      } else {
        stimulusContainer.style.width = stimulusSize + 'px';
        stimulusContainer.style.height = stimulusSize + 'px';
        stimulusContainer.style.maxWidth = stimulusSize + 'px';
        stimulusContainer.style.maxHeight = stimulusSize + 'px';
        promptContainer.style.height = promptHeight + 'px';
      }
    } 
    // TABLET, LAPTOP, DESKTOP: Buttons in a row, horizontal layout
    else {
      const buttonHeight = buttonContainer.offsetHeight;
      console.log('Button height (horizontal):', buttonHeight);
      
      // For horizontal layouts, buttons take less height but more width
      // We want the image to be reasonable size, not blown out
      
      // Calculate available space for stimulus + prompt
      const margin = 60; // More margin for desktop
      const availableHeight = totalHeight - buttonHeight - margin;
      
      // Determine stimulus size based on device
      let maxStimulusPercent;
      if (smallScreen) {
        maxStimulusPercent = 0.75;
      } else if (isTablet) {
        maxStimulusPercent = 0.80;
      } else {
        maxStimulusPercent = 0.70;
      } 
      console.log(availableHeight);
      const stimulusAllocation = availableHeight * maxStimulusPercent;
      const promptAllocation = availableHeight * (1 - maxStimulusPercent);
      
      console.log('Stimulus allocation:', stimulusAllocation);
      console.log('Prompt allocation:', promptAllocation);
      
      // Size stimulus as square, but constrained by both height and reasonable width
      let stimulusSize = Math.min(
        stimulusAllocation,           // Don't exceed allocated height
        totalWidth * 0.80,            // Don't exceed 80% of screen width
        totalHeight * 0.70            // Don't exceed 70% of screen height
      );
      
      console.log('Final stimulus size:', stimulusSize);
      
      stimulusContainer.style.width = stimulusSize + 'px';
      stimulusContainer.style.height = stimulusSize + 'px';
      stimulusContainer.style.maxWidth = stimulusSize + 'px';
      stimulusContainer.style.maxHeight = stimulusSize + 'px';
      stimulusContainer.style.margin = '40px auto'; // Center it
      
      // Prompt gets remaining space
      const actualPromptHeight = totalHeight - stimulusSize - buttonHeight - margin;
      promptContainer.style.height = actualPromptHeight + 'px';
      console.log('Actual prompt height:', actualPromptHeight);
    }
    
    // Style prompt container
    promptContainer.style.display = 'flex';
    promptContainer.style.alignItems = 'center';
    promptContainer.style.justifyContent = 'center';
    promptContainer.style.overflow = 'hidden';
    promptContainer.style.padding = '10px 20px';
    promptContainer.style.margin = '10 auto';
    promptContainer.style.boxSizing = 'border-box';
    
    // Style stimulus to maintain square aspect ratio
    const img = stimulusContainer.querySelector('img') || stimulusContainer;
    if (img) {
      img.style.width = '100%';
      img.style.height = '100%';
      img.style.objectFit = 'contain';
    }
    
    // FIT TEXT TO PROMPT CONTAINER
    const promptText = promptContainer.querySelector('.prompt_text');
    if (promptText && typeof fitTextToContainer === 'function') {
      const promptHeight = promptContainer.offsetHeight;
      
      // Adjust font size ranges based on device
      let minFontSize, maxFontSize;
      if (isMobile) {
        minFontSize = 36;
        maxFontSize = 96;
      } else if (isTablet) {
        minFontSize = 40;
        maxFontSize = 80;
      } else if (smallScreen) {
        minFontSize = 32;
        maxFontSize = 64;
      } else { // desktop
        minFontSize = 32;
        maxFontSize = 64;
      }
      
      fitTextToContainer(promptText, promptHeight - 20, minFontSize, maxFontSize);
      container.classList.add('ready');
    }
  }

  // Default is keyboard here - override if buttons
  //var instr_choice=[' ']; // 32 is space
  //var instr_txt='<i>spacebar</i>'; //
  //var trial_type='';
  //var trial_txt=prompts['k_trial_text']; //
  //var trial_choices=['v','b','n']; //
  var extra_html='';
  if (resp_mode == 'button') {
    //instr_choice=['OK']; //
    //instr_txt='<i>OK</i>'; //
    //trial_type='-buttons';
    //trial_txt='<i>Old</i>, <i>Similar</i>, or <i>New</i>'; //
    //trial_choices=['Old','Similar','New']; //
    extra_html='style="margin-top:112px;"';
    extra_html='';
  }

  //console.log(prompts['k_trial_choices'][0], prompts['k_trial_choices'][1], prompts['k_trial_choices'][2])


  function makeCategorizeTrial(imgPath, keyAnswer, buttonAnswer, promptText, incText, corText) {
    const trial_choices = isMobile ?
      [prompts[resp_mode]['trial_choices']['old'], 
      prompts[resp_mode]['trial_choices']['new'], 
      prompts[resp_mode]['trial_choices']['sim']]
      :
      [prompts[resp_mode]['trial_choices']['old'], 
      prompts[resp_mode]['trial_choices']['sim'], 
      prompts[resp_mode]['trial_choices']['new']];

    return {
      type: jsPsychCategorizeImageButtons,
      stimulus: imgPath,
      key_answer: keyAnswer,
      button_answer: buttonAnswer,
      choices: trial_choices,
      prompt: `
        <div class="prompt-container">
          <p class="prompt prompt_text ${lang}" style="font-weight: normal;">${promptText}</p>
        </div>
      `,
      
      // Set feedback to empty - we'll handle it ourselves
      incorrect_text: '',
      correct_text: '',
      
      force_correct_button_press: true,
      button_html: classicGraphics ?
      trial_choices.map((txt, i) => `
        <div class="image-btn-wrapper">
          <input type="image" 
                src="img/assets/blank_button.png"
                class="image-btn"
                data-choice="${i}"
                data-correct="${i === buttonAnswer}">
          <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
            <text x="50%" y="50%">${txt}</text>
          </svg>
        </div>
      `)
      :
      trial_choices.map((txt, i) => `
        <div class="image-btn-wrapper">
          <input type="image" 
                src="img/assets/blank_${isMobile ? ['red','blue','green'][i] : ['red','green','blue'][i]}.png"
                class="image-btn"
                data-choice="${i}"
                data-correct="${i === buttonAnswer}">
          <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
            <text x="50%" y="50%">${txt}</text>
          </svg>
        </div>
      `),
      
      on_load: function() {
        requestAnimationFrame(() => {
          fitTrialToScreen();
        });

        // Track state
        let hasRespondedIncorrectly = false;
        let isProcessingResponse = false;
        const trialStartTime = performance.now();
        
        // Get all buttons and the container
        const buttonContainer = document.querySelector('#jspsych-categorize-image-buttons-response-btngroup');
        const buttons = document.querySelectorAll('.image-btn');
        
        // Custom feedback function that doesn't redraw
        function showCustomFeedback(correct, text) {
          const promptContainer = document.querySelector('.prompt-container');
          if (!promptContainer) return;
          
          // FIX: Remove the newlines and indentation that cause whitespace
          promptContainer.innerHTML = `<p class="prompt prompt_text ${lang}" style="font-weight: normal; color: ${correct ? 'green' : 'red'};">${text}</p>`;
          
          // FIT THE TEXT
          requestAnimationFrame(() => {
            const promptText = promptContainer.querySelector('.prompt_text');
            if (promptText && typeof fitTextToContainer === 'function') {
              const containerHeight = promptContainer.offsetHeight;
              let minFontSize, maxFontSize;
              if (isMobile) {
                minFontSize = 36;
                maxFontSize = 96;
              } else if (isTablet) {
                minFontSize = 40;
                maxFontSize = 80;
              } else if (smallScreen) {
                minFontSize = 32;
                maxFontSize = 64;
              } else { // desktop
                minFontSize = 32;
                maxFontSize = 64;
              }
              fitTextToContainer(promptText, containerHeight - 20, minFontSize, maxFontSize);
            }
          });
        }

        // Clone buttons to strip their event listeners
        buttons.forEach((btn) => {
          const newBtn = btn.cloneNode(true);
          btn.parentNode.replaceChild(newBtn, btn);
        });
        
        // Add handlers to the clean buttons
        const cleanButtons = document.querySelectorAll('.image-btn');
        
        cleanButtons.forEach((btn) => {
          btn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            // Prevent multiple simultaneous clicks
            if (isProcessingResponse) {
              return false;
            }
            
            const isCorrect = btn.dataset.correct === 'true';
            const choiceIndex = parseInt(btn.dataset.choice);
            
            // CASE 1: First click is incorrect
            if (!hasRespondedIncorrectly && !isCorrect) {
              isProcessingResponse = true;
              hasRespondedIncorrectly = true;
              
              // Show incorrect feedback with proper sizing
              showCustomFeedback(false, incText);
              
              // Allow clicks again after feedback is shown
              setTimeout(() => {
                isProcessingResponse = false;
              }, 100);
              
              return false;
            }
            
            // CASE 2: Already responded incorrectly, clicking another incorrect button
            if (hasRespondedIncorrectly && !isCorrect) {
              return false;
            }
            
            // CASE 3: Clicking correct button (either first try or after incorrect)
            if (isCorrect) {
              isProcessingResponse = true;
              
              // Show correct feedback
              showCustomFeedback(true, corText);
              
              // Wait a moment, then end trial
              setTimeout(() => {
                // Clean up event listeners
                cleanupButtonListeners();
                
                // Finish trial with jsPsych
                const rt = performance.now() - trialStartTime;
                jsPsych.finishTrial({
                  stimulus: imgPath,
                  response: choiceIndex,
                  correct: !hasRespondedIncorrectly, // Only correct if they got it on first try
                  rt: rt,
                  button_answer: buttonAnswer,
                  got_it_wrong_first: hasRespondedIncorrectly
                });
              }, 1500); // Show correct feedback for 1.5 seconds
              
              return false;
            }
            
          }, true); // Use capture phase
        });
        
        // Prevent jsPsych from interfering
        // Override innerHTML setter on the display element to block redraws
        const displayElement = document.querySelector('.jspsych-content');
        const originalInnerHTMLDescriptor = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');
        
        Object.defineProperty(displayElement, 'innerHTML', {
          set: function(value) {
            // Block any attempts to redraw after initial load
            console.log('ðŸ›‘ Blocked jsPsych redraw attempt');
            return;
          },
          get: function() {
            return originalInnerHTMLDescriptor.get.call(this);
          },
          configurable: true
        });

        if (!classicGraphics){
          setupButtonListeners();
        }
      },

      on_finish: function(data) {
        // Restore innerHTML setter
        const displayElement = document.querySelector('.jspsych-content');
        if (displayElement) {
          delete displayElement.innerHTML;
        }

        if (!classicGraphics){
          cleanupButtonListeners();
        }
      },
    };
  }

  function makeSideBySideTrial(imgLeft, imgRight, promptText, buttonLabel) {
    return {
      type: (resp_mode == 'button' ? jsPsychCanvasButtonResponse : jsPsychCanvasKeyboardResponse),
      choices: [buttonLabel],
      canvas_size: calculateSideBySideCanvasSize(isMobile, isTablet, smallScreen), // Calculate based on horizontal allocation
      stimulus: function(c) {
        const ctx = c.getContext('2d');
        ctx.fillStyle = classicGraphics ? 'white' : '#fff9e0';
        const gap = 60; // spacing between the two images
        const framePadding = 20;
        const radius = 25;
        const width = c.width;
        const height = c.height;
        ctx.fillRect(0, 0, width, height);

        const imgL = new Image();
        const imgR = new Image();

        imgL.onload = imgR.onload = function() {
          // Calculate image size to fit within canvas
          // Two images side by side with a gap
          const availableWidth = (width - gap - framePadding * 4) / 2;
          const availableHeight = height - framePadding * 2;
          
          // Use the smaller dimension to ensure images fit
          const imgSize = Math.min(availableWidth, availableHeight);
          
          const imgWidth = imgSize;
          const imgHeight = imgSize;
          const totalWidth = imgWidth * 2 + gap;
          const x = (width - totalWidth) / 2;
          const y = (height - imgHeight) / 2;

          // draw function for each image
          function drawFramedImage(img, xPos) {
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#5d2514';
            ctx.lineWidth = 15;
            if (!classicGraphics) {roundRect(ctx, xPos - framePadding, y - framePadding,
                    imgWidth + 2 * framePadding, imgHeight + 2 * framePadding, radius);}
            ctx.fill();
            ctx.stroke();
            ctx.drawImage(img, xPos, y, imgWidth, imgHeight);
          }
          drawFramedImage(imgL, x);
          drawFramedImage(imgR, x + imgWidth + gap);
        };

        imgL.src = imgLeft;
        imgR.src = imgRight;
      },
      prompt: `<p class="prompt_text" style="margin: 0;">${promptText}</p>`,
      button_html: classicGraphics ?
        `<div class="image-btn-wrapper">
          <input type="image" src="img/assets/blank_button.png"
                class="image-btn">
          <svg class="image-btn-text" viewBox="0 0 266 160">
            <text x="50%" y="50%">${prompts[resp_mode]['instr_choice']}</text>
          </svg>
        </div>`
        :
        `<div class="image-btn-wrapper">
          <input type="image" src="img/assets/blank_green.png"
                class="image-btn">
          <svg class="image-btn-text" viewBox="0 0 266 160">
            <text x="50%" y="50%">${prompts[resp_mode]['instr_choice']}</text>
          </svg>
        </div>`,
      on_load: function() {
        requestAnimationFrame(() => {
          fitSideBySideToScreen(isMobile, isTablet, smallScreen);
        });
        
        if (!classicGraphics){
          setupButtonListeners();
        }
      },

      on_finish: function() {
        if (!classicGraphics){
          cleanupButtonListeners();
        }
      },
    };
  }

var intro = {
  type: (resp_mode == 'button' ? jsPsychHtmlButtonResponse : jsPsychHtmlKeyboardResponse),
  choices: [prompts[resp_mode]['instr_choice']],
  button_html: classicGraphics ?
    `<div class="image-btn-wrapper">
      <input type="image" src="img/assets/blank_button.png"
            class="image-btn">
      <svg class="image-btn-text" viewBox="0 0 266 160">
        <text x="50%" y="50%">${prompts[resp_mode]['instr_choice']}</text>
      </svg>
    </div>`
  :
    `<div class="image-btn-wrapper">
      <input type="image" src="img/assets/blank_green.png"
            class="image-btn">
      <svg class="image-btn-text" viewBox="0 0 266 160">
        <text x="50%" y="50%">${prompts[resp_mode]['instr_choice']}</text>
      </svg>
    </div>`,
  on_load: function() {
    requestAnimationFrame(() => {
      fitIntroOutroToScreen(isMobile, isTablet, smallScreen);
    });

    if (!classicGraphics){
      setupButtonListeners();
    }
  },

  on_finish: function() {
    if (!classicGraphics){
      cleanupButtonListeners();
    }
  },
  prompt: `<p class="prompt_text">${prompts[resp_mode]['prompt0']}</p>`,
  stimulus: `<p class="prompt_text intro ${lang}">` + prompts['txt0'] + '</p>',
}

var new1 = isMobile ?
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}foil_1032${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts['key']['trial_choices']['new'],
    1,
    prompts[resp_mode]['prompt_new'],
    prompts[resp_mode]['inc_new'],
    prompts['cor_new']
  ) 
  :
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}foil_1032${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts[`key`][`trial_choices`][`new`],
    2,
    prompts[resp_mode][`prompt_new`],
    prompts[resp_mode][`inc_new`],
    prompts[`cor_new`]
  )

var new2 = isMobile ?
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}foil_1033${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts[`key`][`trial_choices`][`new`],
    1,
    prompts[resp_mode][`prompt_new`],
    prompts[resp_mode][`inc_new`],
    prompts[`cor_new`]
  )
  :
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}foil_1033${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts[`key`][`trial_choices`][`new`],
    2,
    prompts[resp_mode][`prompt_new`],
    prompts[resp_mode][`inc_new`],
    prompts[`cor_new`]
  );

var new3 = isMobile ?
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}pcon026a${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts[`key`][`trial_choices`][`new`],
    1,
    prompts[resp_mode][`prompt_new`],
    prompts[resp_mode][`inc_new`],
    prompts[`cor_new`]
  )  
  :
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}pcon026a${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts[`key`][`trial_choices`][`new`],
    2,
    prompts[resp_mode][`prompt_new`],
    prompts[resp_mode][`inc_new`],
    prompts[`cor_new`]
  );

var repeat1 = makeCategorizeTrial(
  `img/${classicGraphics ? "" : "assets/"}foil_1033${classicGraphics ? ".jpg" : "_border.png"}`,
  prompts[`key`][`trial_choices`][`old`],
  0,
  prompts[resp_mode][`prompt_rep`],
  prompts[resp_mode][`inc_rep`],
  prompts[`cor_rep`]
);

var lure1 = isMobile ?
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}pcon026b${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts[`key`][`trial_choices`][`sim`],
    2,
    prompts[resp_mode][`prompt_lure`],
    prompts[resp_mode][`inc_lure`],
    prompts[`cor_lure`]
  )
  :
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}pcon026b${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts[`key`][`trial_choices`][`sim`],
    1,
    prompts[resp_mode][`prompt_lure`],
    prompts[resp_mode][`inc_lure`],
    prompts[`cor_lure`]
  );

var side_by_side1 = makeSideBySideTrial(
  `img/pcon026a.jpg`,
  `img/pcon026b.jpg`,
  prompts[`side_by_side`],
  prompts[resp_mode][`instr_choice`]
);

var new4 = isMobile ?
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}foil_1035${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts[`key`][`trial_choices`][`new`],
    1,
    prompts[`prompt_test`] + ` ` + prompts[resp_mode][`trial_txt`],
    prompts[resp_mode][`inc_new`],
    prompts[`cor_new`]
  )
  :
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}foil_1035${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts[`key`][`trial_choices`][`new`],
    2,
    prompts[`prompt_test`] + ` ` + prompts[resp_mode][`trial_txt`],
    prompts[resp_mode][`inc_new`],
    prompts[`cor_new`]
  );

var new5 = isMobile ?
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}pcon028a${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts[`key`][`trial_choices`][`new`],
    1,
    prompts[`prompt_test`] + ` ` + prompts[resp_mode][`trial_txt`],
    prompts[resp_mode][`inc_new`],
    prompts[`cor_new`]
  )
  :
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}pcon028a${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts[`key`][`trial_choices`][`new`],
    2,
    prompts[`prompt_test`] + ` ` + prompts[resp_mode][`trial_txt`],
    prompts[resp_mode][`inc_new`],
    prompts[`cor_new`]
  );

var repeat2 = makeCategorizeTrial(
  `img/${classicGraphics ? "" : "assets/"}foil_1035${classicGraphics ? ".jpg" : "_border.png"}`,
  prompts[`key`][`trial_choices`][`old`],
  0,
  prompts[`prompt_test`] + ` ` + prompts[resp_mode][`trial_txt`],
  prompts[resp_mode][`inc_rep`],
  prompts[`cor_rep`]
);

var lure2 = isMobile ?
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}pcon028b${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts[`key`][`trial_choices`][`sim`],
    2,
    prompts[`prompt_test`] + ` ` + prompts[resp_mode][`trial_txt`],
    prompts[resp_mode][`inc_lure`],
    prompts[`cor_lure`]
  )
  :
  makeCategorizeTrial(
    `img/${classicGraphics ? "" : "assets/"}pcon028b${classicGraphics ? ".jpg" : "_border.png"}`,
    prompts[`key`][`trial_choices`][`sim`],
    1,
    prompts[`prompt_test`] + ` ` + prompts[resp_mode][`trial_txt`],
    prompts[resp_mode][`inc_lure`],
    prompts[`cor_lure`]
  );

var side_by_side2 = makeSideBySideTrial(
  `img/pcon028a.jpg`,
  `img/pcon028b.jpg`,
  prompts[`side_by_side`],
  prompts[resp_mode][`instr_choice`]
);
var outtro = {
  type: (resp_mode == 'button' ? jsPsychHtmlButtonResponse : jsPsychHtmlKeyboardResponse),
  choices: [prompts[resp_mode]['instr_choice']],
  prompt: '<p class="prompt_text">' + prompts[resp_mode]['prompt0'] + '</p>',
  stimulus: `<p class="prompt_text intro">` + prompts['end'] + '</p>', 
  button_html: classicGraphics ?
    `<div class="image-btn-wrapper">
      <input type="image" src="img/assets/blank_button.png"
            class="image-btn">
      <svg class="image-btn-text" viewBox="0 0 266 160">
        <text x="50%" y="50%">${prompts[resp_mode]['instr_choice']}</text>
      </svg>
    </div>`
  :
    `<div class="image-btn-wrapper">
      <input type="image" src="img/assets/blank_green.png"
            class="image-btn">
      <svg class="image-btn-text" viewBox="0 0 266 160">
        <text x="50%" y="50%">${prompts[resp_mode]['instr_choice']}</text>
      </svg>
    </div>`,
  on_load: function() {
    const container = document.querySelector('.jspsych-content');
    container.classList.remove('ready');
    requestAnimationFrame(() => {
      fitIntroOutroToScreen(isMobile, isTablet, smallScreen);
    });
    setupButtonListeners();
  },

  on_finish: function() {
    cleanupButtonListeners();
  },
}

var preload = {
  type: jsPsychPreload,
  images: preload_fnames, // since we use a timeline variable, we can't use the simple "trials"
  show_progress_bar: true,
  show_detailed_erros: true,
  continue_after_error: true,
  on_error: function(fname) {
    console.log('FAILED  '+fname)
  },
  on_finish: function(data) {
    console.log('Preload success? ' + data.success)
    console.log('Failed on ' + data.failed_images.length)
  }
}

var  timeline = [preload, intro, new1, new2, new3, repeat1, lure1, side_by_side1, new4, new5, repeat2, lure2, side_by_side2, outtro];
jsPsych.run(timeline);
    
  
});
</script>
<script src="https://cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>
</html>