<!DOCTYPE html>
<html>
 <!--
  Task: Perceptual-baseline control task in cMST
  Author: Craig Stark
  Forked from cont_omst.html and pcon_gs_v2.html and pcon_instr_gs.html on 6/22/23
  
  8/16/23 (CELS): Fixed for versions without setup.html to progress to next phase
  8/30/23 (CELS): Added getID() to come up with a good sid
  10/23/23 (CELS): Multi-lang support using Honeycomb style language file
  12/12/23 (CELS): Fixed instruction image1 bug (not showing same image)
  12/14/23 (CELS): Enforced image pre-loading

  Optional parameters:
  In the JATOS versions, these come in via jatos.studySessionData but we also can pass
  them in as URL parameters.  Check the code as the actual variable names differ a touch b/n versions. 
  (these are the JATOS ones)

  Optional parameters:
  [sid=##]: Subject ID -- used for data file name (default=1234)
  [resp_mode=X]: Response mode -- set to 'keyboard' to use keyboard, anything else to use buttons (default=buttons)
  [pcrand=#]: Should the trial order be randomized? (default=0, fixed)

  Note, if you use the "baseurl" bit to specify a webserver with the images, you'll need to update the Content-Security-Policy below
  For example, I use:   img-src 'self' https://starklab.bio.uci.edu data: content:;
-->

<head>
  <script>
  console.log('Script running');
  const value = localStorage.getItem('classicGraphics');
  console.log('classicGraphics value:', value);
  console.log('Type:', typeof value);
  // This runs IMMEDIATELY when parsed, before body exists
  const classicGraphics = localStorage.getItem('classicGraphics') === '1';
  
  // Set background on HTML element (which already exists)
  if (classicGraphics) {
    document.documentElement.style.backgroundColor = '#ffffff'; // white
  } else {
    document.documentElement.style.backgroundColor = '#f5f5dc'; // cream
  }
</script>
 <meta http-equiv="Content-Security-Policy" content="default-src 'self' data: gap:  'unsafe-inline' 'unsafe-eval' 
        https://fonts.gstatic.com ; 
      style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/css; media-src *; 
      img-src 'self' data: content:;">
      
  <script type="text/javascript" src="jatos.js"></script>
  <script type="text/javascript" src="js/index.js"></script>
  <script src="js/jquery-3.1.1.min.js"></script>
  <script src="js/jspsych_731/dist/jspsych.js"></script>
  <script src="js/jspsych_731/dist/plugin-html-keyboard-response.js"></script>
  <script src="js/jspsych_731/dist/plugin-image-keyboard-response.js"></script>
  <script src="js/jspsych_731/dist/plugin-html-button-response.js"></script>
  <script src="js/jspsych_731/dist/plugin-image-button-response.js"></script>
  <script src="js/jspsych_731/dist/plugin-canvas-keyboard-response.js"></script>
  <script src="js/jspsych_731/dist/plugin-canvas-button-response.js"></script>
  <script src="js/jspsych_731/dist/plugin-animation.js"></script>
  <script src="js/jspsych_731/dist/plugin-video-keyboard-response.js"></script>
  <script src="js/jspsych_731/dist/plugin-preload.js"></script>
  <script src="helpers.js"></script>
  <link rel="stylesheet" href="css/jspsych.css"></link>
  <link
    rel="preload"
    href="css/fonts/ComicRelief-Regular.woff2"
    as="font"
    type="font/woff2"
    crossorigin
  />
  <link
    rel="preload"
    href="css/fonts/ComicRelief-Bold.woff2"
    as="font"
    type="font/woff2"
    crossorigin
  />
  <style>
    
  .image-btn-text text {
    font-size: 1.5em;
  }
  
  .image-btn-wrapper.pressed .image-btn-text{
    transform: translate(-50%, -40%) !important;
  }

  .mobile .image-btn-text text{
    stroke-width: 12;
    font-size: 1.5em;
  }

  .image-btn-text.kr text {
    font-size: 1.2em;
    stroke-width: 10;
  }
  .image-btn-text.ru text{
    font-size: 0.9em;
    stroke-width: 8;
  }

  .image-btn-text.nl  text{
    font-size: 0.8em;
    stroke-width: 8;
  }

  .mobile .image-btn-text.es text {
    font-size: 1.4em;
  }
  
  .mobile .image-btn-text.kr text {
    font-size: 1.2em;
    stroke-width: 12;
  }

  .mobile .image-btn-text.nl text {
    font-size: 0.8em;
    stroke-width: 8;
  }

  .mobile .image-btn-text.ru text {
    font-size: .8em;
    stroke-width: 8;
  }
  
  .tablet .image-btn-text.kr text {
    font-size: 1.2em;
    stroke-width: 10;
  }

  .tablet .image-btn-text.ru text {
    font-size: 0.8em;
    stroke-width: 8;
  }

  .mobile .prompt_text {
    font-size: 2em;
  }

  .smallScreen .jspsych-categorize-image-buttons-stimulus{
    width: 30vw;
  }

  #jspsych-animation-image {
    width: 25vw;
    height: auto;
  }

  .tablet #jspsych-animation-image {
    width: 50vw;
  }

  .mobile #jspsych-animation-image {
    width: 75vw;
  }

  .smallScreen #jspsych-animation-image {
    width: 30vw;
  }

  .jspsych-content {
    height: 100svh;
    width: 100svw;
    justify-content: center;
  }

  .jspsych-content {
    visibility: hidden !important;
  }

  .jspsych-content.ready {
    visibility: visible !important;
  }

  </style>
</head>
<body></body>

<script>
function waitFor(conditionFunction) {
  const poll = resolve => {
  if(conditionFunction()) resolve();
    else setTimeout(_ => poll(resolve), 400);
  }
  return new Promise(poll)
}

function invNormcdf(p) { // https://stackoverflow.com/questions/8816729/javascript-equivalent-for-inverse-normal-function-eg-excels-normsinv-or-nor
  var a1 = -39.6968302866538, a2 = 220.946098424521, a3 = -275.928510446969;
  var a4 = 138.357751867269, a5 = -30.6647980661472, a6 = 2.50662827745924;
  var b1 = -54.4760987982241, b2 = 161.585836858041, b3 = -155.698979859887;
  var b4 = 66.8013118877197, b5 = -13.2806815528857, c1 = -7.78489400243029E-03;
  var c2 = -0.322396458041136, c3 = -2.40075827716184, c4 = -2.54973253934373;
  var c5 = 4.37466414146497, c6 = 2.93816398269878, d1 = 7.78469570904146E-03;
  var d2 = 0.32246712907004, d3 = 2.445134137143, d4 = 3.75440866190742;
  var p_low = 0.02425, p_high = 1 - p_low;
  var q, r;
  var retVal;

  if ((p < 0) || (p > 1))
  {
    alert("NormSInv: Argument out of range.");
    retVal = 0;
  }
  else if (p < p_low)
  {
    q = Math.sqrt(-2 * Math.log(p));
    retVal = (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
  }
  else if (p <= p_high)
  {
    q = p - 0.5;
    r = q * q;
    retVal = (((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * q / (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1);
  }
  else
  {
    q = Math.sqrt(-2 * Math.log(1 - p));
    retVal = -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
  }

  return retVal;
}

function getID() {
  // Try to get a reasonable ID code for this person.  You can use the URL with a "sid" parameter or
  // specify one in the jatos studySessionData. If not, it'll use the JATOS workerId.
  // URL > studySession > workerID
  var sid=jatos.urlQueryParameters.sid;
  if (sid == undefined) {
    sid=jatos.studySessionData['sid'];
  }
  if (typeof sid == 'undefined') {
    if (typeof jatos.workerId !== 'undefined') { // At least try the workerID
      sid = jatos.workerId;
    }
    else { sid=1234; }
  }
  return sid
}

jatos.onLoad(async function() {
  //baseurl='https://starklab.bio.uci.edu/mst/'; // How we'll get images, videos, etc.  Set to empty string to use local folders
  baseurl=''; // How we'll get images, videos, etc.  Set to empty string to use local folders
  var sid=getID();

  var resp_mode='button';
  if (jatos.studySessionData['resp_mode'] == 'keyboard') {
    resp_mode='key';
  }
  else if (jatos.studySessionData['resp_mode'] == 'key') {
    resp_mode='key';
  }

  var lang='en';
  
  if (typeof jatos.studySessionData['lang'] !== 'undefined') {
    lang=jatos.studySessionData['lang'];
  }
  if (jatos.studyJsonInput && typeof jatos.studyJsonInput['lang'] !== 'undefined' ) { 
    lang=jatos.studyJsonInput['lang']
  }
  if (jatos.batchJsonInput && typeof jatos.batchJsonInput['lang'] !== 'undefined' ) { 
    lang=jatos.batchJsonInput['lang']
  }
  
  if (jatos.studySessionData['resp_mode'] == 'keyboard') {
    resp_mode='keyboard';
  }
  var randomize=false;
  if (jatos.studySessionData['pcrand'] == 1) {
    randomize = true;
  }

  var classicGraphics = 0;
  if (typeof jatos.studySessionData['plain_graphics'] !== 'undefined') {
    classicGraphics = jatos.studySessionData['plain_graphics'];
  }
  if (jatos.studyJsonInput && typeof jatos.studyJsonInput['plain_graphics'] !== 'undefined' ) { 
    classicGraphics=jatos.studyJsonInput['plain_graphics']
  }
  if (jatos.batchJsonInput && typeof jatos.batchJsonInput['plain_graphics'] !== 'undefined' ) { 
    classicGraphics=jatos.batchJsonInput['plain_graphics']
  }

  // load honeycomb version of lang file
  console.log('loading json lang')
  var langfile='lang/omst_'+lang+'.json';
  var json_prompts=null;
  $.getJSON(langfile,function( data ) {
    //console.log( data ); // Data returned
    json_prompts=data;
    console.debug(langfile + ' loaded...ish');
  });
  //console.log(json_prompts['consent'])
  await waitFor(_ => json_prompts !== null);
  console.log(json_prompts['task']['name'])
  let prompts=json_prompts['pcon'] // Load in this phase's section

  const phasename='pcon';

  var jsPsych = initJsPsych({on_finish: function() {
    if (0) { jsPsych.data.displayData(); }
      else {
        var order=jatos.studySessionData["order"];
        jatos.studySessionData["taskindex"] += 1;
        var expdata = jsPsych.data.get().json();
        if (typeof order === 'undefined') {
          // We don't have an 'order' setup, so assume it's 1-N
          console.log('faking an order')
          order=Array(jatos.componentList.length).fill().map((e,i)=>i+1);
          jatos.studySessionData["taskindex"]=jatos.componentPos;
          //console.log(order);
          //console.log(jatos.studySessionData["taskindex"]);
        }
        // Submit results to JATOS and queue the end or next task
        if (typeof order === 'undefined' || order.length == jatos.studySessionData["taskindex"]) { 
          // we're done
          // Check if this came from SONA - should have URL.sid and .sona
          if (typeof jatos.urlQueryParameters.sid === 'undefined' || typeof jatos.urlQueryParameters.sona === 'undefined' ||
              typeof jatos.studyJsonInput['experiment_id'] === 'undefined' || typeof jatos.studyJsonInput['credit_token'] === 'undefined') {
            jatos.submitResultData(expdata,jatos.endStudy);
          }
          else {
            // This is here for SONA experiments.  You'll want to tweak it for your own online setup, but this gives you the return to them for credit
            var redirect='https://uci.sona-systems.com/webstudy_credit.aspx?experiment_id='+jatos.studyJsonInput['experiment_id']+
              '&credit_token='+jatos.studyJsonInput['credit_token']+'&survey_code='+jatos.urlQueryParameters.sid;
            jatos.endStudyAndRedirect(redirect,expdata);
          }
        }
        else {
          // submit and start the next
          jatos.submitResultData(expdata, () => { jatos.startComponentByPos(order[jatos.studySessionData["taskindex"]]) });
        }
      }
    }
  });
  const device = getDeviceType();
  console.log("have device " + device);
  const isMobile = device[0];
  const isTablet = device[1];
  const smallScreen = device[2];
  console.log("smallScreen " + smallScreen);
  const canvasWidth = isMobile ? window.innerWidth * 0.9 : window.innerWidth * .9;
  const canvasHeight = isMobile ? window.innerHeight * 0.7 : smallScreen ? window.innerHeight * 0.75 : isTablet ? window.innerHeight * 0.8 : window.innerHeight * .75;
  const fontScale = isMobile ? 1.5 : 1.0;
  const stimScale = isMobile ? 2 : smallScreen ? 0.85: isTablet ? 1.2 : 1.0;
  document.body.classList.add(isMobile ? 'mobile' : 'desktop');
  if (smallScreen) {document.body.classList.add('smallScreen');}
  if (isTablet) {document.body.classList.add('tablet');}
  if (classicGraphics) {document.body.classList.add('classic');}
  jsPsych.data.addProperties({
    task: phasename,
    subject: sid,
    randomize: randomize
});

  function makeSideBySideTrial(imgLeft, imgRight, promptText, buttonLabel) {
    return {
      type: (resp_mode == 'button' ? jsPsychCanvasButtonResponse : jsPsychCanvasKeyboardResponse),
      choices: [buttonLabel],
      canvas_size: calculateSideBySideCanvasSize(isMobile, isTablet, smallScreen), // Calculate based on horizontal allocation
      stimulus: function(c) {
        const ctx = c.getContext('2d');
        ctx.fillStyle = classicGraphics ? "white" : '#fff9e0';
        const gap = 60; // spacing between the two images
        const framePadding = 20;
        const radius = 25;
        const width = c.width;
        const height = c.height;
        ctx.fillRect(0, 0, width, height);

        const imgL = new Image();
        const imgR = new Image();

        imgL.onload = imgR.onload = function() {
          // Calculate image size to fit within canvas
          // Two images side by side with a gap
          const availableWidth = (width - gap - framePadding * 4) / 2;
          const availableHeight = height - framePadding * 2;
          
          // Use the smaller dimension to ensure images fit
          const imgSize = Math.min(availableWidth, availableHeight);
          
          const imgWidth = imgSize;
          const imgHeight = imgSize;
          const totalWidth = imgWidth * 2 + gap;
          const x = (width - totalWidth) / 2;
          const y = (height - imgHeight) / 2;

          // draw function for each image
          function drawFramedImage(img, xPos) {
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#5d2514';
            ctx.lineWidth = 15;
            if (!classicGraphics) {roundRect(ctx, xPos - framePadding, y - framePadding,
                    imgWidth + 2 * framePadding, imgHeight + 2 * framePadding, radius);}
            ctx.fill();
            ctx.stroke();
            ctx.drawImage(img, xPos, y, imgWidth, imgHeight);
          }
          drawFramedImage(imgL, x);
          drawFramedImage(imgR, x + imgWidth + gap);
        };

        imgL.src = imgLeft;
        imgR.src = imgRight;
      },
      prompt: `<p class="prompt_text" style="margin: 0;">${promptText}</p>`,
      button_html: classicGraphics ?
        `<div class="image-btn-wrapper">
          <input type="image" src="img/assets/blank_button.png"
                class="image-btn">
          <svg class="image-btn-text" viewBox="0 0 266 160">
            <text x="50%" y="50%">${prompts[resp_mode]['instr_choice']}</text>
          </svg>
        </div>`
      :
        `<div class="image-btn-wrapper">
          <input type="image" src="img/assets/blank_green.png"
                class="image-btn">
          <svg class="image-btn-text" viewBox="0 0 266 160">
            <text x="50%" y="50%">${prompts[resp_mode]['instr_choice']}</text>
          </svg>
        </div>`,
      on_load: function() {

        requestAnimationFrame(() => {
          fitSideBySideToScreen(isMobile, isTablet, smallScreen);
        });

        setupButtonListeners();
      },

      on_finish: function() {
        cleanupButtonListeners();
      },
    };
  }
  // Setup prompts and response options based on keyboard/button and 2/3 choices
  // var instr_choice=[' ']; // 32 is space
  // var instr_txt='<i>spacebar</i>';
  // var trial_txt='<b>S</b>ame or <b>D</b>ifferent';
  // if (resp_mode == 'button') {
  //     instr_choice=['OK'];
  //     instr_txt='<i>OK</i>'
  //     trial_txt='<i>Same</i> or <i>Different</i>'
  // }

  var noise_sequence = ['img/noise_1.png', 'img/noise_2.png','img/noise_3.png','img/noise_4.png','img/noise_5.png']; 

  var preload = {
    type: jsPsychPreload,// since we use a timeline variable, we can't use the auto reliably
    images: ['img/noise_1.png', 'img/noise_2.png','img/noise_3.png','img/noise_4.png','img/noise_5.png',
    'img/pprac1a.jpg','img/pprac2a.jpg','img/pprac2b.jpg',
    'img/pcon001a.jpg','img/pcon001b.jpg', 
    'img/pcon002a.jpg','img/pcon002a.jpg', 
    'img/pcon003a.jpg','img/pcon003a.jpg', 
    'img/pcon004a.jpg','img/pcon004b.jpg', 
    'img/pcon005a.jpg','img/pcon005a.jpg', 
    'img/pcon006a.jpg','img/pcon006a.jpg', 
    'img/pcon007a.jpg','img/pcon007a.jpg', 
    'img/pcon008a.jpg','img/pcon008b.jpg', 
    'img/pcon009a.jpg','img/pcon009b.jpg', 
    'img/pcon010a.jpg','img/pcon010b.jpg', 
    'img/pcon011a.jpg','img/pcon011a.jpg', 
    'img/pcon012a.jpg','img/pcon012b.jpg', 
    'img/pcon013a.jpg','img/pcon013a.jpg', 
    'img/pcon014a.jpg','img/pcon014b.jpg', 
    'img/pcon015a.jpg','img/pcon015a.jpg', 
    'img/pcon016a.jpg','img/pcon016b.jpg', 
    'img/pcon017a.jpg','img/pcon017a.jpg', 
    'img/pcon018a.jpg','img/pcon018a.jpg', 
    'img/pcon019a.jpg','img/pcon019a.jpg', 
    'img/pcon020a.jpg','img/pcon020b.jpg', 
    'img/pcon021a.jpg','img/pcon021b.jpg', 
    'img/pcon022a.jpg','img/pcon022a.jpg', 
    'img/pcon023a.jpg','img/pcon023b.jpg', 
    'img/pcon024a.jpg','img/pcon024b.jpg', 
    'img/pcon025a.jpg','img/pcon025b.jpg', 
    'img/pcon027a.jpg','img/pcon027a.jpg',
    "img/assets/blank_blue.png",
    "img/assets/blank_blue_pressed.png",
    "img/assets/blank_green.png",
    "img/assets/blank_green_pressed.png",
    "img/noise_animation.mp4" ], 
    show_progress_bar: true,
    show_detailed_erros: true,
    continue_after_error: true,
    on_error: function(fname) {
      console.log('FAILED  '+fname)
    },
    on_finish: function(data) {
      console.log('Preload success? ' + data.success)
      console.log('Failed on ' + data.failed_images.length)
    }
  }
  
  // Instruction phase
  var instr1_trial = {
    type: (resp_mode == 'button' ? jsPsychHtmlButtonResponse : jsPsychHtmlKeyboardResponse),
    choices: [prompts[resp_mode]['instr_choice']],
    button_html: classicGraphics ?
        `<div class="image-btn-wrapper">
          <input type="image" src="img/assets/blank_button.png"
                class="image-btn">
          <svg class="image-btn-text" viewBox="0 0 266 160">
            <text x="50%" y="50%">${prompts[resp_mode]['instr_choice']}</text>
          </svg>
        </div>`
    :
        `<div class="image-btn-wrapper">
          <input type="image" src="img/assets/blank_green.png"
                class="image-btn">
          <svg class="image-btn-text" viewBox="0 0 266 160">
            <text x="50%" y="50%">${prompts[resp_mode]['instr_choice']}</text>
          </svg>
        </div>`,
    on_load: function() {
      requestAnimationFrame(() => {
        fitIntroOutroToScreen(isMobile, isTablet, smallScreen);
      });

      setupButtonListeners();
    },
    on_finish: function() {
      cleanupButtonListeners();
    },

    prompt: `<p class="prompt_text">${prompts[resp_mode]['instr1_prompt']}</p>`,
    stimulus: `<p class="prompt_text intro" >` + prompts['instr1_stim'] + '</p>',

  }

  var demo1_trial = {
    timeline: [
      {
        type:  jsPsychHtmlKeyboardResponse,
        choices:  "NO_KEYS",
        trial_duration: 1000,
        response_ends_trial: false,
        stimulus: `<p class="prompt_text" >` + prompts['ready'] + '</p>',
        on_load: function() {
          const contentDiv = document.querySelector('.jspsych-content');
          if (contentDiv) {
            contentDiv.classList.remove('start');
          }
        }
      },
      {
        //type: (resp_mode == 'button' ? jsPsychImageButtonResponse : jsPsychImageKeyboardResponse),
        //choices: (resp_mode == 'button' ? ['Same','Different'] : "NO_KEYS"),
        //button_html: '<button class="jspsych-btn dimtext">%choice%</button>',
        type: jsPsychCanvasKeyboardResponse,

        // Canvas stimulus
        stimulus: function(c) {
          const ctx = c.getContext('2d');
          const width = c.width;
          const height = c.height;
          const stimImg = new Image();
          const stimPath = jsPsych.timelineVariable('img1');
          const framePadding = 20;
          const radius = 25;

          const drawBase = function(){
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, width, height);
          }

          stimImg.onload = function() {
            const imgWidth = isMobile ? stimImg.width * 1.5 : isTablet ? stimImg.width * 1.2 : smallScreen ? stimImg.width * 1.2 : stimImg.width * 1.2;
            const imgHeight = isMobile ? stimImg.height * 1.5 : isTablet ? stimImg.height * 1.2 : smallScreen ? stimImg.height * 1.2 : stimImg.height * 1.2;
            const x = (width - imgWidth) / 2;
            const y = (height - imgHeight) / 2 - (isMobile ? 0 : 0); // shift up slightly

            ctx.fillStyle = "#ffffff";
            ctx.strokeStyle = '#5d2514';
            ctx.lineWidth = 15;
            if (!classicGraphics) {roundRect(ctx, x - framePadding, y - framePadding,
                    imgWidth + 2 * framePadding, imgHeight + 2 * framePadding, radius);}
            ctx.fill();
            ctx.stroke();

            ctx.drawImage(stimImg, x, y, imgWidth, imgHeight);
          };
          stimImg.src = stimPath;
        },
        choices: "NO_KEYS",
        canvas_size: [canvasHeight, canvasWidth],
        trial_duration: 2000,
        response_ends_trial: false,
      },
      {
        type: jsPsychAnimation,
        stimuli: noise_sequence,
        sequence_reps: 2,
        frame_time: 200,
        render_on_canvas: true,
        prompt: `<p class="prompt_text" style="visibility: hidden;" id="animation-prompt">${prompts['wait']}</p>`,
        on_start: function(trial) {
          // The trial won't render until this Promise resolves
          console.log('Preloading animation images before showing anything...');
          
          return new Promise((resolve) => {
            let loadedCount = 0;
            const totalImages = trial.stimuli.length;
            const images = [];
            
            trial.stimuli.forEach((src, index) => {
              const img = new Image();
              
              img.onload = () => {
                loadedCount++;
                console.log(`Loaded ${loadedCount}/${totalImages}`);
                
                if (loadedCount === totalImages) {
                  console.log('ALL IMAGES LOADED. Now showing animation trial.');
                  resolve(); // This allows the trial to render
                }
              };
              
              img.onerror = () => {
                console.error(`Failed to load image ${index}: ${src}`);
                loadedCount++;
                if (loadedCount === totalImages) {
                  resolve();
                }
              };
              
              img.src = src;
              images.push(img);
            });
          });
        },
        on_load: function() {
          // This runs AFTER on_start resolves and trial is displayed
          const canvas = document.querySelector('canvas');

          if (canvas) {
            canvas.style.width = canvasWidth;
            canvas.style.height = canvasHeight;
            canvas.style.objectFit = 'contain';
            canvas.style.display = 'block';
            canvas.style.margin = '0 auto';
          }

          const content = document.querySelector('.jspsych-content');
          if (content) {
            content.style.textAlign = 'center';
          }
          
          const promptText = document.getElementById('animation-prompt');
          if (promptText) {
            promptText.style.visibility = 'visible';
          }

          console.log('Animation trial is now visible and running');
        }
      },
      {
        type: (resp_mode == 'button' ? jsPsychCanvasButtonResponse : jsPsychCanvasKeyboardResponse),

        // Canvas stimulus
        stimulus: function(c) {
          const ctx = c.getContext('2d');
          const width = c.width;
          const height = c.height;
          const stimImg = new Image();
          const stimPath = jsPsych.timelineVariable('img2');
          const framePadding = 20;
          const radius = 25;

          const drawBase = function(){
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, width, height);
          }

          stimImg.onload = function() {
            const imgWidth = isMobile ? stimImg.width * 1.5 : isTablet ? stimImg.width * 1.2 : smallScreen ? stimImg.width * 1.2 : stimImg.width * 1.2;
            const imgHeight = isMobile ? stimImg.height * 1.5 : isTablet ? stimImg.height * 1.2 : smallScreen ? stimImg.height * 1.2 : stimImg.height * 1.2;
            const x = (width - imgWidth) / 2;
            const y = (height - imgHeight) / 2 - (isMobile ? 0 : 0); // shift up slightly

            ctx.fillStyle = "#ffffff";
            ctx.strokeStyle = '#5d2514';
            ctx.lineWidth = 15;
            if(!classicGraphics) {roundRect(ctx, x - framePadding, y - framePadding,
                    imgWidth + 2 * framePadding, imgHeight + 2 * framePadding, radius);}
            ctx.fill();
            ctx.stroke();

            ctx.drawImage(stimImg, x, y, imgWidth, imgHeight);


          };
          stimImg.src = stimPath;
        },
        choices: [ prompts[resp_mode]['trial_choices']['same'], prompts[resp_mode]['trial_choices']['dif'] ],
        //stimulus_duration: 2000,
        canvas_size: [canvasHeight * .95, canvasWidth],
        trial_duration: null,
        response_ends_trial: true,
        margin_horizontal: '40px',
        button_html: classicGraphics ?
        [
          `<div class="image-btn-wrapper">
            <input type="image" src="img/assets/blank_button.png"
                  class="image-btn">
            <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
              <text x="50%" y="50%">%choice%</text>
            </svg>
          </div>`,

          `<div class="image-btn-wrapper">
            <input type="image" src="img/assets/blank_button.png"
                  class="image-btn">
            <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
              <text x="50%" y="50%">%choice%</text>
            </svg>
          </div>`,
        ]
        :
        [
          `<div class="image-btn-wrapper">
            <input type="image" src="img/assets/blank_green.png"
                  class="image-btn">
            <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
              <text x="50%" y="50%">%choice%</text>
            </svg>
          </div>`,

          `<div class="image-btn-wrapper">
            <input type="image" src="img/assets/blank_blue.png"
                  class="image-btn">
            <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
              <text x="50%" y="50%">%choice%</text>
            </svg>
          </div>`,
        ],
        on_load: function() {
          setupButtonListeners();
        },

        on_finish: function() {
          cleanupButtonListeners();
        },
      },
    ],
    timeline_variables: [
      { img1: 'img/pprac1a.jpg', img2: 'img/pprac1a.jpg'}
    ]
  }
  var instr2_trial = makeSideBySideTrial(
    'img/pprac1a.jpg',
    'img/pprac1a.jpg',
    prompts['instr2_stim'],
    prompts[resp_mode]['instr_choice']
  );
  
  var demo2_trial = {
    timeline: [
      {
        type:  jsPsychHtmlKeyboardResponse,
        choices:  "NO_KEYS",
        trial_duration: 500,
        response_ends_trial: false,
        stimulus: `<p class="prompt_text">` + prompts['ready'] + '</p>',
      },
      {
        //type: (resp_mode == 'button' ? jsPsychImageButtonResponse : jsPsychImageKeyboardResponse),
        //choices: (resp_mode == 'button' ? ['Same','Different'] : "NO_KEYS"),
        //button_html: '<button class="jspsych-btn dimtext">%choice%</button>',
        type: jsPsychCanvasKeyboardResponse,

        // Canvas stimulus
        stimulus: function(c) {
          const ctx = c.getContext('2d');
          const width = c.width;
          const height = c.height;
          const stimImg = new Image();
          const stimPath = jsPsych.timelineVariable('img1');
          const framePadding = 20;
          const radius = 25;

          const drawBase = function(){
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, width, height);
          }

          stimImg.onload = function() {
            const imgWidth = isMobile ? stimImg.width * 1.5 : isTablet ? stimImg.width * 1.2 : smallScreen ? stimImg.width * 1.2 : stimImg.width * 1.2;
            const imgHeight = isMobile ? stimImg.height * 1.5 : isTablet ? stimImg.height * 1.2 : smallScreen ? stimImg.height * 1.2 : stimImg.height * 1.2;
            const x = (width - imgWidth) / 2;
            const y = (height - imgHeight) / 2 - (isMobile ? 0 : 0); // shift up slightly

            ctx.fillStyle = "#ffffff";
            ctx.strokeStyle = '#5d2514';
            ctx.lineWidth = 15;
            if(!classicGraphics) {roundRect(ctx, x - framePadding, y - framePadding,
                    imgWidth + 2 * framePadding, imgHeight + 2 * framePadding, radius);}
            ctx.fill();
            ctx.stroke();

            ctx.drawImage(stimImg, x, y, imgWidth, imgHeight);
          };
          stimImg.src = stimPath;
        },
        choices: "NO_KEYS",
        canvas_size: [canvasHeight, canvasWidth],
        trial_duration: 2000,
        response_ends_trial: false,
      },
      {
        type: jsPsychAnimation,
        stimuli: noise_sequence,
        sequence_reps: 2,
        frame_time: 200,
        render_on_canvas: true,
        prompt: `<p class="prompt_text" style="visibility: hidden;" id="animation-prompt">${prompts['wait']}</p>`,
        on_start: function(trial) {
          // The trial won't render until this Promise resolves
          console.log('Preloading animation images before showing anything...');
          
          return new Promise((resolve) => {
            let loadedCount = 0;
            const totalImages = trial.stimuli.length;
            const images = [];
            
            trial.stimuli.forEach((src, index) => {
              const img = new Image();
              
              img.onload = () => {
                loadedCount++;
                console.log(`Loaded ${loadedCount}/${totalImages}`);
                
                if (loadedCount === totalImages) {
                  console.log('ALL IMAGES LOADED. Now showing animation trial.');
                  resolve(); // This allows the trial to render
                }
              };
              
              img.onerror = () => {
                console.error(`Failed to load image ${index}: ${src}`);
                loadedCount++;
                if (loadedCount === totalImages) {
                  resolve();
                }
              };
              
              img.src = src;
              images.push(img);
            });
          });
        },
        on_load: function() {
          // This runs AFTER on_start resolves and trial is displayed
          const canvas = document.querySelector('canvas');

          if (canvas) {
            canvas.style.width = canvasWidth;
            canvas.style.height = canvasHeight;
            canvas.style.objectFit = 'contain';
            canvas.style.display = 'block';
            canvas.style.margin = '0 auto';
          }

          const content = document.querySelector('.jspsych-content');
          if (content) {
            content.style.textAlign = 'center';
          }
          
          // NOW reveal the prompt text
          const promptText = document.getElementById('animation-prompt');
          if (promptText) {
            promptText.style.visibility = 'visible';
          }

          console.log('Animation trial is now visible and running');
        }
      },
      {
        type: (resp_mode == 'button' ? jsPsychCanvasButtonResponse : jsPsychCanvasKeyboardResponse),

        // Canvas stimulus
        stimulus: function(c) {
          const ctx = c.getContext('2d');
          const width = c.width;
          const height = c.height;
          const stimImg = new Image();
          const stimPath = jsPsych.timelineVariable('img2');
          const framePadding = 20;
          const radius = 25;

          const drawBase = function(){
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, width, height);
          }

          stimImg.onload = function() {
            const imgWidth = isMobile ? stimImg.width * 1.5 : isTablet ? stimImg.width * 1.2 : smallScreen ? stimImg.width * 1.2 : stimImg.width * 1.2;
            const imgHeight = isMobile ? stimImg.height * 1.5 : isTablet ? stimImg.height * 1.2 : smallScreen ? stimImg.height * 1.2 : stimImg.height * 1.2;
            const x = (width - imgWidth) / 2;
            const y = (height - imgHeight) / 2 - (isMobile ? 0 : 0); // shift up slightly

            ctx.fillStyle = "#ffffff";
            ctx.strokeStyle = '#5d2514';
            ctx.lineWidth = 15;
            if(!classicGraphics) {roundRect(ctx, x - framePadding, y - framePadding,
                    imgWidth + 2 * framePadding, imgHeight + 2 * framePadding, radius);}
            ctx.fill();
            ctx.stroke();
            
            ctx.drawImage(stimImg, x, y, imgWidth, imgHeight);


          };
          stimImg.src = stimPath;
        },
        choices: [ prompts[resp_mode]['trial_choices']['same'], prompts[resp_mode]['trial_choices']['dif'] ],
        //stimulus_duration: 2000,
        canvas_size: [canvasHeight * .95, canvasWidth],
        trial_duration: null,
        response_ends_trial: true,
        margin_horizontal: '40px',
        button_html: classicGraphics ?
        [
          `<div class="image-btn-wrapper">
            <input type="image" src="img/assets/blank_button.png"
                  class="image-btn">
            <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
              <text x="50%" y="50%">%choice%</text>
            </svg>
          </div>`,

          `<div class="image-btn-wrapper">
            <input type="image" src="img/assets/blank_button.png"
                  class="image-btn">
            <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
              <text x="50%" y="50%">%choice%</text>
            </svg>
          </div>`,
        ]
        :
        [
          `<div class="image-btn-wrapper">
            <input type="image" src="img/assets/blank_green.png"
                  class="image-btn">
            <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
              <text x="50%" y="50%">%choice%</text>
            </svg>
          </div>`,

          `<div class="image-btn-wrapper">
            <input type="image" src="img/assets/blank_blue.png"
                  class="image-btn">
            <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
              <text x="50%" y="50%">%choice%</text>
            </svg>
          </div>`,
        ],
        on_load: function() {
          setupButtonListeners();
        },

        on_finish: function() {
          cleanupButtonListeners();
        },
      },
    ],
    timeline_variables: [
      { img1: 'img/pprac2a.jpg', img2: 'img/pprac2b.jpg'}
    ]
  }
  var instr3_trial = makeSideBySideTrial(
    'img/pprac2a.jpg',
    'img/pprac2b.jpg',
    prompts['instr3_stim'],
    prompts[resp_mode]['instr_choice']
  );
  
  
  // Main phase
  var test_trials = {
    timeline: [
      {
        type:  jsPsychHtmlKeyboardResponse,
        choices:  "NO_KEYS",
        trial_duration: 500,
        response_ends_trial: false,
        stimulus: `<p class="prompt_text">` + prompts['ready'] + '</p>',
      },
      {
        //type: (resp_mode == 'button' ? jsPsychImageButtonResponse : jsPsychImageKeyboardResponse),
        //choices: (resp_mode == 'button' ? ['Same','Different'] : "NO_KEYS"),
        //button_html: '<button class="jspsych-btn dimtext">%choice%</button>',
        type: jsPsychCanvasKeyboardResponse,

        // Canvas stimulus
        stimulus: function(c) {
          const ctx = c.getContext('2d');
          const width = c.width;
          const height = c.height;
          const stimImg = new Image();
          const stimPath = jsPsych.timelineVariable('img1');
          const framePadding = 20;
          const radius = 25;

          const drawBase = function(){
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, width, height);
          }

          stimImg.onload = function() {
            const imgWidth = isMobile ? stimImg.width * 1.5 : isTablet ? stimImg.width * 1.2 : smallScreen ? stimImg.width * 1.2 : stimImg.width * 1.2;
            const imgHeight = isMobile ? stimImg.height * 1.5 : isTablet ? stimImg.height * 1.2 : smallScreen ? stimImg.height * 1.2 : stimImg.height * 1.2;
            const x = (width - imgWidth) / 2;
            const y = (height - imgHeight) / 2 - (isMobile ? 0 : 0); // shift up slightly

            ctx.fillStyle = "#ffffff";
            ctx.strokeStyle = '#5d2514';
            ctx.lineWidth = 15;
            if (!classicGraphics) {roundRect(ctx, x - framePadding, y - framePadding,
                    imgWidth + 2 * framePadding, imgHeight + 2 * framePadding, radius);}
            ctx.fill();
            ctx.stroke();

            ctx.drawImage(stimImg, x, y, imgWidth, imgHeight);
          };
          stimImg.src = stimPath;
        },
        on_start: function(trial) {
          // The trial won't render until this Promise resolves
          console.log('Preloading animation images before showing anything...');
          
          return new Promise((resolve) => {
            let loadedCount = 0;
            const totalImages = noise_sequence.length;
            const images = [];
            
            noise_sequence.forEach((src, index) => {
              const img = new Image();
              
              img.onload = () => {
                loadedCount++;
                console.log(`Loaded ${loadedCount}/${totalImages}`);
                
                if (loadedCount === totalImages) {
                  console.log('ALL IMAGES LOADED. Now showing animation trial.');
                  resolve(); // This allows the trial to render
                }
              };
              
              img.onerror = () => {
                console.error(`Failed to load image ${index}: ${src}`);
                loadedCount++;
                if (loadedCount === totalImages) {
                  resolve();
                }
              };
              
              img.src = src;
              images.push(img);
            });

          });
        },
        choices: "NO_KEYS",
        canvas_size: [canvasHeight, canvasWidth],
        trial_duration: 2000,
        response_ends_trial: false,
        
      },
      {
        type: jsPsychAnimation,
        stimuli: noise_sequence,
        sequence_reps: 2,
        frame_time: 200,
        render_on_canvas: true,
        prompt: `<p class="prompt_text" style="visibility: hidden;" id="animation-prompt">${prompts['wait']}</p>`,
        on_start: function(trial) {
          // The trial won't render until this Promise resolves
          console.log('Preloading animation images before showing anything...');
          
          return new Promise((resolve) => {
            let loadedCount = 0;
            const totalImages = trial.stimuli.length;
            const images = [];
            
            trial.stimuli.forEach((src, index) => {
              const img = new Image();
              
              img.onload = () => {
                loadedCount++;
                console.log(`Loaded ${loadedCount}/${totalImages}`);
                
                if (loadedCount === totalImages) {
                  console.log('ALL IMAGES LOADED. Now showing animation trial.');
                  resolve(); // This allows the trial to render
                }
              };
              
              img.onerror = () => {
                console.error(`Failed to load image ${index}: ${src}`);
                loadedCount++;
                if (loadedCount === totalImages) {
                  resolve();
                }
              };
              
              img.src = src;
              images.push(img);
            });

          });
        },
        on_load: function() {
          // This runs AFTER on_start resolves and trial is displayed
          const canvas = document.querySelector('canvas');

          if (canvas) {
            canvas.style.width = canvasWidth;
            canvas.style.height = canvasHeight;
            canvas.style.objectFit = 'contain';
            canvas.style.display = 'block';
            canvas.style.margin = '0 auto';
          }

          const content = document.querySelector('.jspsych-content');
          if (content) {
            content.style.textAlign = 'center';
          }
            
          // NOW reveal the prompt text
          const promptText = document.getElementById('animation-prompt');
          if (promptText) {
            promptText.style.visibility = 'visible';
          }

          console.log('Animation trial is now visible and running');
        }
      },
      {

        type: (resp_mode == 'button' ? jsPsychCanvasButtonResponse : jsPsychCanvasKeyboardResponse),

        // Canvas stimulus
        stimulus: function(c) {
          const ctx = c.getContext('2d');
          const width = c.width;
          const height = c.height;
          const stimImg = new Image();
          const stimPath = jsPsych.timelineVariable('img2');
          const framePadding = 20;
          const radius = 25;

          const drawBase = function(){
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, width, height);
          }

          stimImg.onload = function() {
            const imgWidth = isMobile ? stimImg.width * 1.5 : isTablet ? stimImg.width * 1.2 : smallScreen ? stimImg.width * 1.2 : stimImg.width * 1.2;
            const imgHeight = isMobile ? stimImg.height * 1.5 : isTablet ? stimImg.height * 1.2 : smallScreen ? stimImg.height * 1.2 : stimImg.height * 1.2;
            const x = (width - imgWidth) / 2;
            const y = (height - imgHeight) / 2 - (isMobile ? 0 : 0); // shift up slightly

            ctx.fillStyle = "#ffffff";
            ctx.strokeStyle = '#5d2514';
            ctx.lineWidth = 15;
            if(!classicGraphics) {roundRect(ctx, x - framePadding, y - framePadding,
                    imgWidth + 2 * framePadding, imgHeight + 2 * framePadding, radius);}
            ctx.fill();
            ctx.stroke();

            ctx.drawImage(stimImg, x, y, imgWidth, imgHeight);


          };
          stimImg.src = stimPath;
        },
        choices: [ prompts[resp_mode]['trial_choices']['same'], prompts[resp_mode]['trial_choices']['dif'] ],
        //stimulus_duration: 2000,
        canvas_size: [canvasHeight * .95, canvasWidth],
        trial_duration: null,
        response_ends_trial: true,
        margin_horizontal: '40px',
        post_trial_gap: 500,
        button_html: classicGraphics ?
        [
          `<div class="image-btn-wrapper">
            <input type="image" src="img/assets/blank_button.png"
                  class="image-btn">
            <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
              <text x="50%" y="50%">%choice%</text>
            </svg>
          </div>`,

          `<div class="image-btn-wrapper">
            <input type="image" src="img/assets/blank_button.png"
                  class="image-btn">
            <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
              <text x="50%" y="50%">%choice%</text>
            </svg>
          </div>`,
        ]
        :
        [
          `<div class="image-btn-wrapper">
            <input type="image" src="img/assets/blank_green.png"
                  class="image-btn">
            <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
              <text x="50%" y="50%">%choice%</text>
            </svg>
          </div>`,

          `<div class="image-btn-wrapper">
            <input type="image" src="img/assets/blank_blue.png"
                  class="image-btn">
            <svg class="image-btn-text ${lang}" viewBox="0 0 266 160">
              <text x="50%" y="50%">%choice%</text>
            </svg>
          </div>`,
        ],
        on_load: function() {
          setupButtonListeners();
        },

        on_finish: function(data) {
          cleanupButtonListeners();
          // same = button 0 = 's'
          // different = button 1 = 'd'
          let resp = null;
          if (resp_mode == 'button') {
              if (data.response == 0) { resp = 's' }
              else if (data.response == 1 ) { resp = 'd' }
          } 
          else { // Sure, we cuold just copy, but leaving it like this if we change keys used
              if (data.response == 's') { resp = 's' }
              else if (data.response == 'd' ) { resp = 'd' }
          } 
          //console.log(data.cresp, jsPsych.timelineVariable('cresp'))
          data.cresp=jsPsych.timelineVariable('cresp'),
          data.correct =  resp == data.cresp;
          data.resp = resp;
          console.log(data.resp,data.cresp,data.correct)
        }
      },

    ],
    timeline_variables: [
      { img1: 'img/pcon001a.jpg', img2: 'img/pcon001b.jpg', cresp: 'd'},
      { img1: 'img/pcon002a.jpg', img2: 'img/pcon002a.jpg', cresp: 's'},
      { img1: 'img/pcon003a.jpg', img2: 'img/pcon003a.jpg', cresp: 's'},
      { img1: 'img/pcon004a.jpg', img2: 'img/pcon004b.jpg', cresp: 'd'},
      { img1: 'img/pcon005a.jpg', img2: 'img/pcon005a.jpg', cresp: 's'},
      { img1: 'img/pcon006a.jpg', img2: 'img/pcon006a.jpg', cresp: 's'},
      { img1: 'img/pcon007a.jpg', img2: 'img/pcon007a.jpg', cresp: 's'},
      { img1: 'img/pcon008a.jpg', img2: 'img/pcon008b.jpg', cresp: 'd'},
      { img1: 'img/pcon009a.jpg', img2: 'img/pcon009b.jpg', cresp: 'd'},
      { img1: 'img/pcon010a.jpg', img2: 'img/pcon010b.jpg', cresp: 'd'},
      { img1: 'img/pcon011a.jpg', img2: 'img/pcon011a.jpg', cresp: 's'},
      { img1: 'img/pcon012a.jpg', img2: 'img/pcon012b.jpg', cresp: 'd'},
      { img1: 'img/pcon013a.jpg', img2: 'img/pcon013a.jpg', cresp: 's'},
      { img1: 'img/pcon014a.jpg', img2: 'img/pcon014b.jpg', cresp: 'd'},
      { img1: 'img/pcon015a.jpg', img2: 'img/pcon015a.jpg', cresp: 's'},
      { img1: 'img/pcon016a.jpg', img2: 'img/pcon016b.jpg', cresp: 'd'},
      { img1: 'img/pcon017a.jpg', img2: 'img/pcon017a.jpg', cresp: 's'},
      { img1: 'img/pcon018a.jpg', img2: 'img/pcon018a.jpg', cresp: 's'},
      { img1: 'img/pcon019a.jpg', img2: 'img/pcon019a.jpg', cresp: 's'},
      { img1: 'img/pcon020a.jpg', img2: 'img/pcon020b.jpg', cresp: 'd'},
      { img1: 'img/pcon021a.jpg', img2: 'img/pcon021b.jpg', cresp: 'd'},
      { img1: 'img/pcon022a.jpg', img2: 'img/pcon022a.jpg', cresp: 's'},
      { img1: 'img/pcon023a.jpg', img2: 'img/pcon023b.jpg', cresp: 'd'},
      { img1: 'img/pcon024a.jpg', img2: 'img/pcon024b.jpg', cresp: 'd'},
      { img1: 'img/pcon025a.jpg', img2: 'img/pcon025b.jpg', cresp: 'd'},
      //{ img1: 'img/pcon026a.jpg', img2: 'img/pcon026b.jpg', cresp: 'd'},
      { img1: 'img/pcon027a.jpg', img2: 'img/pcon027a.jpg', cresp: 's'},     
      //{ img1: 'img/pcon028a.jpg', img2: 'img/pcon028a.jpg', cresp: 's'},
    ],
    randomize_order: randomize
  }

  var summary_block = {
    type: jsPsychHtmlKeyboardResponse,
    trial_duration: 500,
    stimulus: `<p class="prompt_text" style="font-size: ${isMobile ? 1 : (smallScreen ? ((lang=='ru') ? 0.6 : 0.65) : ((lang=='ru') ? 0.85 : 1))}em;font-weight: normal;">` + prompts['ty'] + '</p>',
    response_ends_trial: false,
    on_finish: function (data) {
      let validtrials=jsPsych.data.get().filterCustom(function(trial) {
        return trial.resp !== null; 
      })
      let targets=validtrials.filter({cresp: 's'});
      let foils=validtrials.filter({cresp: 'd'});

      let corr_targs = targets.filter({correct: true});
      let corr_foils = foils.filter({correct: true});
      let hits=Math.round(corr_targs.count() / targets.count() * 100);
      let crs=Math.round(corr_foils.count() / foils.count() * 100);
      let p_fa = 0.0;
      let p_hit = 0.0;
      if (corr_targs.count() == 0) { p_hit = 0.5 / targets.count(); }
      else if (corr_targs.count() == targets.count() ) { p_hit = (targets.count() - 0.5) / targets.count(); }
      else { p_hit=corr_targs.count() / targets.count(); }

      if (corr_foils.count() == foils.count()) { p_fa = 0.5 / foils.count(); }
      else if (corr_foils.count() ==0 ) {p_fa = (foils.count() - 0.5) / foils.count(); }
      else { p_fa=1-(corr_foils.count() / foils.count()); }

      console.log(corr_targs.count() + " " + targets.count() + " " + p_hit)
      console.log(corr_foils.count() + " " + foils.count() + " " + p_fa)
      console.log(invNormcdf(p_hit))
      console.log(invNormcdf(p_fa))

      let dpTF = invNormcdf(p_hit) - invNormcdf(p_fa); 

      var retstr = 'HR, ' + hits + ', CR rate, ' + crs + ", d'T:F, " + dpTF.toFixed(3)  
      let date = new Date(); 
      let dcode = date.getFullYear() + "-" + (date.getMonth()+1) + "-" + (date.getDate()+1) + 
        "-" + date.getHours() + "-" + date.getMinutes() + "-" + date.getSeconds();
      
      if (!jatos.batchSession.defined("/" + sid)) {  // Should have this by now, but to be safe -- make sure to create this as an array
        jatos.batchSession.add("/" + sid,[phasename+"_"+dcode+"_"+retstr]);
      }
      else { // Append to array
        jatos.batchSession.add("/" + sid + "/-",phasename+"_"+dcode+"_"+retstr);
      }
      data.summary = retstr;
    }
  }
    

    var timeline = [preload, instr1_trial, demo1_trial, instr2_trial, demo2_trial, instr3_trial, test_trials, summary_block];

  jsPsych.run(timeline);
  
      
});
</script>

</html>
